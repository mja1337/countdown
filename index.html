<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Meeting Countdown</title>
  <style>
    :root{
      --bg1:#0b1020;
      --bg2:#0f1b3a;
      --card:rgba(255,255,255,.08);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.68);
      --accent:#7c5cff;
      --danger:#ff3d71;
      --shadow: 0 18px 50px rgba(0,0,0,.35);
      --radius: 22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 20% 10%, rgba(124,92,255,.35), transparent 60%),
        radial-gradient(900px 700px at 80% 30%, rgba(39,232,167,.25), transparent 55%),
        linear-gradient(160deg, var(--bg1), var(--bg2));
      display:flex;
      align-items:center;
      justify-content:center;
      padding:28px;
    }

    .wrap{
      width:min(1040px, 100%);
      display:grid;
      grid-template-columns: 1fr;
      gap:18px;
    }

    .card{
      background:linear-gradient(180deg, var(--card), rgba(255,255,255,.05));
      border:1px solid rgba(255,255,255,.14);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:22px;
      backdrop-filter: blur(10px);
    }

    header{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:16px;
      flex-wrap:wrap;
    }

    h1{
      font-size: clamp(20px, 3vw, 28px);
      margin:0 0 6px 0;
      letter-spacing:.2px;
    }
    .sub{
      margin:0;
      color:var(--muted);
      font-size:14px;
      line-height:1.4;
    }

    .clock{
      font-family: var(--mono);
      font-size: clamp(46px, 7vw, 84px);
      letter-spacing: 1.5px;
      display:flex;
      align-items:baseline;
      justify-content:center;
      padding:18px 14px;
      border-radius:18px;
      background:linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.05));
      border:1px solid rgba(255,255,255,.12);
      margin-top:16px;
      user-select:none;
      text-align:center;
      line-height:1.05;
    }
    .clock small{
      font-family:var(--sans);
      font-size:14px;
      color:var(--muted);
      margin-left:12px;
      letter-spacing:0;
      display:inline-block;
      vertical-align:baseline;
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:12px;
      margin-top:14px;
    }

    .field{
      grid-column: span 12;
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    label{
      font-size:13px;
      color:var(--muted);
    }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    input, button, select{
      font: inherit;
      color: var(--text);
    }

    input, select{
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.16);
      border-radius: 14px;
      padding: 12px 12px;
      outline: none;
      transition: border .15s ease, background .15s ease;
      min-width: 260px;
    }
    input:focus, select:focus{
      border-color: rgba(124,92,255,.75);
      background: rgba(0,0,0,.32);
    }

    input.small, select.small{
      min-width: 170px;
    }

    .btns{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
    }

    button{
      border:1px solid rgba(255,255,255,.18);
      background: linear-gradient(180deg, rgba(124,92,255,.85), rgba(124,92,255,.55));
      padding:12px 14px;
      border-radius: 14px;
      cursor:pointer;
      box-shadow: 0 10px 22px rgba(124,92,255,.18);
      transition: transform .12s ease, filter .12s ease, box-shadow .12s ease;
      font-weight: 650;
      letter-spacing:.2px;
      white-space:nowrap;
    }
    button:hover{ transform: translateY(-1px); filter: brightness(1.05); }
    button:active{ transform: translateY(0px); filter: brightness(.98); }

    button.secondary{
      background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
      box-shadow:none;
      font-weight:600;
    }

    button.danger{
      background: linear-gradient(180deg, rgba(255,61,113,.85), rgba(255,61,113,.55));
      box-shadow: 0 10px 22px rgba(255,61,113,.16);
    }

    button.tiny{
      padding:10px 12px;
      font-weight:650;
    }

    .meta{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      justify-content:space-between;
      margin-top:10px;
      color:var(--muted);
      font-size:13px;
    }
    .pill{
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
    }

    .flash{
      animation: flash 0.6s steps(2, end) infinite;
      border-color: rgba(255,61,113,.8) !important;
      box-shadow: 0 0 0 3px rgba(255,61,113,.18), var(--shadow);
    }
    @keyframes flash{
      0%{ opacity:1; }
      50%{ opacity:.15; }
      100%{ opacity:1; }
    }

    .hint{
      margin-top:12px;
      font-size:13px;
      color:var(--muted);
      line-height:1.5;
    }

    .warn{
      color: rgba(255,255,255,.85);
      background: rgba(255,61,113,.12);
      border: 1px solid rgba(255,61,113,.25);
      padding: 10px 12px;
      border-radius: 14px;
      margin-top: 12px;
      display:none;
    }
    .warn.show{ display:block; }

    @media (min-width: 900px){
      .field.time { grid-column: span 8; }
      .field.actions { grid-column: span 4; }
      .btns{ justify-content:flex-start; height:100%; align-content:flex-end; }
      .clock{ margin-top:18px; }
    }
  </style>
</head>
<body>
  <main class="wrap">
    <section class="card">
      <header>
        <div>
          <h1>Meeting Countdown</h1>
          <p class="sub">
            Set meeting start + end. Break defaults to halfway, but you can change duration and push the break start.
          </p>
        </div>
        <div class="pill" id="nowPill">Now: --:--:--</div>
      </header>

      <div class="clock" id="display">00:00:00 <small id="status">Ready</small></div>

      <div class="grid">
        <div class="field time">
          <label>Meeting times</label>
          <div class="row">
            <input id="startAt" type="datetime-local" />
            <input id="endAt" type="datetime-local" />
          </div>
          <div class="row">
            <button class="secondary tiny" data-preset="30" type="button">Now + 30m</button>
            <button class="secondary tiny" data-preset="60" type="button">Now + 1h</button>
            <button class="secondary tiny" data-preset="120" type="button">Now + 2h</button>
            <button class="secondary tiny" data-preset="180" type="button">Now + 3h</button>
            <button class="secondary tiny" data-preset="240" type="button">Now + 4h</button>
          </div>
        </div>

        <div class="field actions">
          <label>Actions</label>
          <div class="btns">
            <button id="start" type="button">Start</button>
            <button class="secondary" id="pause" type="button">Pause</button>
            <button class="danger" id="reset" type="button">Reset</button>
          </div>
        </div>

        <div class="field">
          <label>Break settings</label>
          <div class="row">
            <select id="breakMinutes" class="small">
              <option value="5" selected>Break length: 5 min</option>
              <option value="10">Break length: 10 min</option>
              <option value="15">Break length: 15 min</option>
              <option value="20">Break length: 20 min</option>
            </select>

            <input id="breakStartExact" class="small" type="time" step="60" placeholder="Break start (HH:MM)" />
            <button class="secondary tiny" id="applyExactBreak" type="button">Set exact</button>

            <button class="secondary tiny" id="breakNow" type="button">Break now</button>
            <button class="secondary tiny" id="minus5" type="button">-5m</button>
            <button class="secondary tiny" id="plus5" type="button">+5m</button>
            <button class="secondary tiny" id="resetBreak" type="button">Reset break</button>
          </div>
          <div class="hint" id="breakHint">
            Halfway break is computed from start/end. “Set exact” pins break start. +/- buttons push/pull the break start.
          </div>
        </div>
      </div>

      <div class="warn" id="warn"></div>

      <div class="meta">
        <div class="pill" id="meetingPill">Meeting: —</div>
        <div class="pill" id="breakPill">Break: —</div>
        <div class="pill" id="modePill">Mode: Not running</div>
      </div>

      <p class="hint">
        Close protection: while running/paused, closing the tab prompts you. Browsers may ignore custom text.
      </p>
    </section>
  </main>

  <script>
    const el = (id) => document.getElementById(id);

    const startAtInput = el("startAt");
    const endAtInput = el("endAt");

    const startBtn = el("start");
    const pauseBtn = el("pause");
    const resetBtn = el("reset");

    const breakMinutesSelect = el("breakMinutes");
    const breakStartExactInput = el("breakStartExact");
    const applyExactBreakBtn = el("applyExactBreak");
    const breakNowBtn = el("breakNow");
    const minus5Btn = el("minus5");
    const plus5Btn = el("plus5");
    const resetBreakBtn = el("resetBreak");

    const display = el("display");
    const status = el("status");
    const nowPill = el("nowPill");
    const meetingPill = el("meetingPill");
    const breakPill = el("breakPill");
    const modePill = el("modePill");
    const warnBox = el("warn");
    const breakHint = el("breakHint");

    const STORAGE_KEY = "meeting-countdown:v2";

    let timerId = null;

    let meetingStart = null;
    let meetingEnd = null;

    // Break controls:
    // - breakDurationMinutes: length of break
    // - breakOffsetMinutes: offset applied to the default halfway break start
    // - breakPinnedStartMs: if set, break start is pinned to an absolute timestamp (ms)
    let breakDurationMinutes = 5;
    let breakOffsetMinutes = 0;
    let breakPinnedStartMs = null;

    let paused = false;
    let remainingWhenPausedMs = null;
    let pausedMode = null; // "pre" | "meeting"

    // --- Helpers ---
    const pad2 = (n) => String(n).padStart(2, "0");

    function formatHMS(ms) {
      const totalSeconds = Math.max(0, Math.floor(ms / 1000));
      const h = Math.floor(totalSeconds / 3600);
      const m = Math.floor((totalSeconds % 3600) / 60);
      const s = totalSeconds % 60;
      return `${pad2(h)}:${pad2(m)}:${pad2(s)}`;
    }

    function setDisplay(text, flash=false) {
      display.childNodes[0].nodeValue = text + " ";
      display.classList.toggle("flash", flash);
    }

    function toLocalDateTimeValue(d) {
      const yyyy = d.getFullYear();
      const mm = pad2(d.getMonth() + 1);
      const dd = pad2(d.getDate());
      const hh = pad2(d.getHours());
      const mi = pad2(d.getMinutes());
      return `${yyyy}-${mm}-${dd}T${hh}:${mi}`;
    }

    function prettyTime(d) {
      return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });
    }

    function prettyDateTime(d) {
      return d.toLocaleString([], {
        weekday: "short",
        month: "short",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
      });
    }

    function showWarn(msg) {
      warnBox.textContent = msg;
      warnBox.classList.add("show");
    }
    function clearWarn() {
      warnBox.textContent = "";
      warnBox.classList.remove("show");
    }

    function parseInputs() {
      clearWarn();

      const s = startAtInput.value ? new Date(startAtInput.value) : null;
      const e = endAtInput.value ? new Date(endAtInput.value) : null;

      if (!s || Number.isNaN(s.getTime())) {
        showWarn("Start time is missing/invalid.");
        return null;
      }
      if (!e || Number.isNaN(e.getTime())) {
        showWarn("End time is missing/invalid.");
        return null;
      }
      if (e.getTime() <= s.getTime()) {
        showWarn("End time must be after start time.");
        return null;
      }
      return { s, e };
    }

    function defaultHalfBreakStartMs(s, e) {
      const durationMs = e.getTime() - s.getTime();
      return s.getTime() + Math.floor(durationMs / 2);
    }

    function computeBreakWindow(s, e) {
      const baseStartMs = defaultHalfBreakStartMs(s, e);

      const startMs =
        (breakPinnedStartMs != null ? breakPinnedStartMs : baseStartMs) +
        (breakPinnedStartMs != null ? 0 : breakOffsetMinutes * 60_000);

      const bStart = new Date(startMs);
      const bEnd = new Date(startMs + breakDurationMinutes * 60_000);
      return { bStart, bEnd, baseStartMs };
    }

    function saveState() {
      if (!meetingStart || !meetingEnd) return;
      const payload = {
        start: meetingStart.toISOString(),
        end: meetingEnd.toISOString(),
        breakDurationMinutes,
        breakOffsetMinutes,
        breakPinnedStartMs
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
    }

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return false;
        const parsed = JSON.parse(raw);
        if (!parsed?.start || !parsed?.end) return false;

        const s = new Date(parsed.start);
        const e = new Date(parsed.end);
        if (Number.isNaN(s.getTime()) || Number.isNaN(e.getTime())) return false;

        startAtInput.value = toLocalDateTimeValue(s);
        endAtInput.value = toLocalDateTimeValue(e);

        breakDurationMinutes = Number(parsed.breakDurationMinutes ?? 5);
        breakOffsetMinutes = Number(parsed.breakOffsetMinutes ?? 0);
        breakPinnedStartMs =
          (parsed.breakPinnedStartMs === null || parsed.breakPinnedStartMs === undefined)
            ? null
            : Number(parsed.breakPinnedStartMs);

        breakMinutesSelect.value = String(breakDurationMinutes);
        updateBreakHint();

        return true;
      } catch {
        return false;
      }
    }

    function isActive() {
      // treat paused as "active" for close protection
      return Boolean(timerId) || paused;
    }

    // Close protection
    window.addEventListener("beforeunload", (e) => {
      if (!isActive()) return;
      e.preventDefault();
      e.returnValue = "";
      return "";
    });

    // --- Live "Now" pill ---
    setInterval(() => {
      nowPill.textContent = "Now: " + prettyTime(new Date());
    }, 250);

    function updateBreakHint() {
      if (breakPinnedStartMs != null) {
        breakHint.textContent = `Break is pinned to an exact start time. Reset break to return to halfway. Break length: ${breakDurationMinutes} min.`;
      } else if (breakOffsetMinutes !== 0) {
        const dir = breakOffsetMinutes > 0 ? "later" : "earlier";
        breakHint.textContent = `Break is halfway, shifted ${Math.abs(breakOffsetMinutes)} min ${dir}. Break length: ${breakDurationMinutes} min.`;
      } else {
        breakHint.textContent = `Break is halfway. Break length: ${breakDurationMinutes} min.`;
      }
    }

    function refreshMeta() {
      if (!meetingStart || !meetingEnd) {
        meetingPill.textContent = "Meeting: —";
        breakPill.textContent = "Break: —";
        return;
      }

      meetingPill.textContent = `Meeting: ${prettyDateTime(meetingStart)} → ${prettyDateTime(meetingEnd)}`;

      const { bStart, bEnd } = computeBreakWindow(meetingStart, meetingEnd);
      breakPill.textContent = `Break: ${prettyTime(bStart)}–${prettyTime(bEnd)} (${breakDurationMinutes}m)`;

      updateBreakHint();
    }

    // --- Core loop ---
    function tick() {
      if (!meetingStart || !meetingEnd) return;

      const now = new Date();

      const preMeeting = now.getTime() < meetingStart.getTime();
      const finished = now.getTime() >= meetingEnd.getTime();

      const { bStart, bEnd } = computeBreakWindow(meetingStart, meetingEnd);
      const msToBreak = bStart.getTime() - now.getTime();
      const inBreak = now.getTime() >= bStart.getTime() && now.getTime() < bEnd.getTime();

      const flash = (msToBreak > 0 && msToBreak <= 30_000) || inBreak;

      if (finished) {
        setDisplay("00:00:00", true);
        status.textContent = "Done";
        modePill.textContent = "Mode: Finished";
        stopTimer(false);
        return;
      }

      if (preMeeting) {
        const msToStart = meetingStart.getTime() - now.getTime();
        setDisplay(formatHMS(msToStart), flash);
        status.textContent = "Until start";
        modePill.textContent = "Mode: Waiting to start";

        breakPill.textContent =
          `Break: ${prettyTime(bStart)}–${prettyTime(bEnd)} (in ${formatHMS(msToBreak)})`;
        return;
      }

      const msToEnd = meetingEnd.getTime() - now.getTime();
      setDisplay(formatHMS(msToEnd), flash);
      status.textContent = inBreak ? "On break" : "Until end";
      modePill.textContent = inBreak ? `Mode: Break (${breakDurationMinutes}m)` : "Mode: Running";

      if (inBreak) {
        const msToBreakEnd = bEnd.getTime() - now.getTime();
        breakPill.textContent = `Break: NOW (ends in ${formatHMS(msToBreakEnd)})`;
      } else if (now.getTime() < bStart.getTime()) {
        breakPill.textContent = `Break: ${prettyTime(bStart)}–${prettyTime(bEnd)} (in ${formatHMS(msToBreak)})`;
      } else {
        breakPill.textContent = `Break: done (${prettyTime(bStart)}–${prettyTime(bEnd)})`;
      }
    }

    function startTimer() {
      // Resume path
      if (paused && remainingWhenPausedMs != null && pausedMode) {
        const now = Date.now();

        if (pausedMode === "pre") {
          const parsed = parseInputs();
          const durationMs = parsed
            ? (parsed.e.getTime() - parsed.s.getTime())
            : (meetingEnd && meetingStart ? (meetingEnd.getTime() - meetingStart.getTime()) : 30 * 60 * 1000);

          meetingStart = new Date(now + remainingWhenPausedMs);
          meetingEnd = new Date(meetingStart.getTime() + durationMs);
        } else {
          meetingEnd = new Date(now + remainingWhenPausedMs);
          if (!meetingStart) {
            const parsed = parseInputs();
            meetingStart = parsed ? parsed.s : new Date(now);
          }
        }

        paused = false;
        remainingWhenPausedMs = null;
        pausedMode = null;
      } else {
        const parsed = parseInputs();
        if (!parsed) return;

        meetingStart = parsed.s;
        meetingEnd = parsed.e;
      }

      refreshMeta();
      saveState();

      display.classList.remove("flash");
      stopTimer(false);
      tick();
      timerId = setInterval(tick, 200);
    }

    function stopTimer(resetModeText=true) {
      if (timerId) {
        clearInterval(timerId);
        timerId = null;
      }
      if (resetModeText) modePill.textContent = "Mode: Not running";
    }

    function pauseTimer() {
      if (!timerId || !meetingStart || !meetingEnd) return;

      const now = Date.now();

      if (now < meetingStart.getTime()) {
        remainingWhenPausedMs = meetingStart.getTime() - now;
        pausedMode = "pre";
      } else {
        remainingWhenPausedMs = Math.max(0, meetingEnd.getTime() - now);
        pausedMode = "meeting";
      }

      paused = true;
      stopTimer(false);

      status.textContent = "Paused";
      modePill.textContent = "Mode: Paused";
      setDisplay(formatHMS(remainingWhenPausedMs), false);
      saveState();
    }

    function resetAll() {
      stopTimer(true);
      meetingStart = null;
      meetingEnd = null;

      paused = false;
      remainingWhenPausedMs = null;
      pausedMode = null;

      display.classList.remove("flash");
      setDisplay("00:00:00", false);
      status.textContent = "Ready";
      meetingPill.textContent = "Meeting: —";
      breakPill.textContent = "Break: —";
      clearWarn();
    }

    function setPresetNowPlus(minutes) {
      const now = new Date();
      const end = new Date(now.getTime() + minutes * 60 * 1000);
      startAtInput.value = toLocalDateTimeValue(now);
      endAtInput.value = toLocalDateTimeValue(end);

      // New meeting => reset break overrides (sane default)
      breakPinnedStartMs = null;
      breakOffsetMinutes = 0;
      updateBreakHint();

      // If running/paused, restart cleanly
      if (timerId || paused) {
        paused = false;
        remainingWhenPausedMs = null;
        pausedMode = null;
        startTimer();
      } else {
        // Not running: just refresh the pills
        const parsed = parseInputs();
        if (parsed) {
          meetingStart = parsed.s;
          meetingEnd = parsed.e;
          refreshMeta();
          meetingStart = null;
          meetingEnd = null;
        }
      }
      saveState();
    }

    function applyBreakDurationFromUI() {
      const v = Number(breakMinutesSelect.value);
      breakDurationMinutes = Number.isFinite(v) && v > 0 ? v : 5;
      updateBreakHint();
      refreshMeta();
      saveState();
      tick();
    }

    function nudgeBreak(minutes) {
      // nudging a pinned break moves the pin too (explicit "push it out")
      if (breakPinnedStartMs != null) {
        breakPinnedStartMs += minutes * 60_000;
      } else {
        breakOffsetMinutes += minutes;
      }
      updateBreakHint();
      refreshMeta();
      saveState();
      tick();
    }

    function setExactBreakFromUI() {
      const parsed = parseInputs();
      if (!parsed) return;

      const timeVal = breakStartExactInput.value; // "HH:MM"
      if (!timeVal || !/^\d{2}:\d{2}$/.test(timeVal)) {
        showWarn("Enter break time as HH:MM (24h).");
        return;
      }
      clearWarn();

      const [hh, mm] = timeVal.split(":").map(Number);
      const d = new Date(parsed.s);
      d.setHours(hh, mm, 0, 0);

      // Clamp into meeting window
      if (d.getTime() < parsed.s.getTime()) d.setTime(parsed.s.getTime());
      if (d.getTime() >= parsed.e.getTime()) d.setTime(parsed.e.getTime() - 60_000);

      breakPinnedStartMs = d.getTime();
      breakOffsetMinutes = 0;

      updateBreakHint();
      refreshMeta();
      saveState();
      tick();
    }

    function breakNow() {
      const parsed = parseInputs();
      if (!parsed) return;

      let t = Date.now();

      // Clamp into meeting window
      if (t < parsed.s.getTime()) t = parsed.s.getTime();
      if (t >= parsed.e.getTime()) t = parsed.e.getTime() - 60_000;

      breakPinnedStartMs = t;
      breakOffsetMinutes = 0;

      updateBreakHint();
      refreshMeta();
      saveState();
      tick();
    }

    function resetBreakOverrides() {
      breakPinnedStartMs = null;
      breakOffsetMinutes = 0;
      updateBreakHint();
      refreshMeta();
      saveState();
      tick();
    }

    // --- UI wiring ---
    startBtn.addEventListener("click", startTimer);
    pauseBtn.addEventListener("click", pauseTimer);
    resetBtn.addEventListener("click", () => {
      localStorage.removeItem(STORAGE_KEY);
      resetAll();
      // reset break controls too
      breakDurationMinutes = 5;
      breakOffsetMinutes = 0;
      breakPinnedStartMs = null;
      breakMinutesSelect.value = "5";
      breakStartExactInput.value = "";
      updateBreakHint();
    });

    document.querySelectorAll("button[data-preset]").forEach((btn) => {
      btn.addEventListener("click", () => {
        const mins = Number(btn.getAttribute("data-preset"));
        setPresetNowPlus(mins);
      });
    });

    breakMinutesSelect.addEventListener("change", applyBreakDurationFromUI);
    applyExactBreakBtn.addEventListener("click", setExactBreakFromUI);
    breakNowBtn.addEventListener("click", breakNow);
    minus5Btn.addEventListener("click", () => nudgeBreak(-5));
    plus5Btn.addEventListener("click", () => nudgeBreak(+5));
    resetBreakBtn.addEventListener("click", resetBreakOverrides);

    // Make Enter start the timer when editing fields
    [startAtInput, endAtInput].forEach((node) => {
      node.addEventListener("keydown", (e) => {
        if (e.key === "Enter") startTimer();
      });
    });

    // Initialize
    nowPill.textContent = "Now: " + prettyTime(new Date());

    // Load previous times if present, otherwise set a sane default (Now + 30m)
    if (!loadState()) {
      setPresetNowPlus(30);
    }

    // Show pills based on inputs without auto-start
    (function primePills() {
      const parsed = parseInputs();
      if (!parsed) return;
      meetingStart = parsed.s;
      meetingEnd = parsed.e;
      refreshMeta();
      meetingStart = null;
      meetingEnd = null;
      clearWarn();
    })();

    // Keep pills updated when user edits times (but don't start)
    [startAtInput, endAtInput].forEach((node) => {
      node.addEventListener("change", () => {
        const parsed = parseInputs();
        if (!parsed) return;
        meetingStart = parsed.s;
        meetingEnd = parsed.e;
        refreshMeta();
        meetingStart = null;
        meetingEnd = null;
        saveState();
      });
    });
  </script>
</body>
</html>
